## Задание

1. Изучить временные характеристики алгоритмов.
2. Изучить методы поиска подстроки в строке.
3. Программно реализовать 2 метода: алгоритм Shift-Or, алгоритм Бойера-Мура.

4\.Разработать и программно реализовать средство для проведения экспериментов по определению временных характеристик алгоритмов.

5\. Определить порядок функций временной сложности алгоритмов.

## Алгоритмы решения задач

Для алгоритма Shift-Or сначала строится матрица состоящая из единиц размера n\*(m+1), где n - длина искомого паттерна, m - длина строки. Вводится операция сдвига столбца, при котором последний элемент теряется, а в начало добавляется 0. Вводится операция получения битной маски паттерна по символу K. Данная операция возвращает вектор длины n(как длина паттерна), состоящий из нулей и единиц. Нули стоят на тех местах маски, где есть вхождение символа K в паттерн. Далее в цикле для всех столбцов, начиная с нулевого столбца матрицы, применяем к столбцу операцию сдвига, а к символу(соответствующему номеру сдвинутого столбца) строки, в которой ищем паттерн, применяем операцию получения битной маски. Далее выполняем побитовое ИЛИ для столбца(который мы сдвигали в первом шаге) и битной маске(которую мы получали по символу строки во втором шаге). Полученный результат операции записываем в следующий столбец за сдвинутым. Когда окажется, что последний элемент столбца 0, то мы нашли полное вхождение паттерна в строку. Не обязательно хранить всю матрицу в памяти, достаточно хранить предыдущий и текущий столбец.

Алгоритм Бойера-Мура включает в себя предобработку искомого паттерна. Мы составляем словарь-алфавит из символов паттерна, где каждому ключу(символу) присваиваем значение расстояния от этого символа в паттерне до конца паттерна. Схема поиска паттерна в строке следующая. Мы двигаемся по строке слева направо, сравниваем символы паттерна же мы справа налево. То есть мы начинаем поиск не с нулевого символа строки а с n-1, где n-длина паттерна. Также мы делаем прыжки на расстояние n если символ строки не входит в наш словарь-алфавит. Если при сравнении паттерна и строки символы не совпали, но при этом сравниваемый символ в строке содержится в нашем словаре-алфавите то мы делаем прыжок на значение лежащее по данному ключу(символу).

## Сравнительный анализ алгоритмов

Временные затраты алгоритмов для разных строк показаны в таблице 1.

Таблица 1



<table><tr><th colspan="1" rowspan="2" valign="top">Алгоритм</td><th colspan="4" valign="top">Количество символов в строке</td></tr>
<tr></td><td colspan="1" valign="top">60</td><td colspan="1" valign="top">120</td><td colspan="1" valign="top">240</td><td colspan="1" valign="top">480</td></tr>
<tr><td colspan="1" valign="top">Shift-Or</td><td colspan="1" valign="top">148348 ns</td><td colspan="1" valign="top">296249 ns</td><td colspan="1" valign="top">555988 ns</td><td colspan="1" valign="top">1212235 ns</td></tr>
<tr><td colspan="1">Бойера-Мура</td><td colspan="1" valign="top">18000 ns</td><td colspan="1" valign="top">29068 ns</td><td colspan="1" valign="top">52670 ns</td><td colspan="1" valign="top">127286 ns</td></tr>
</table>

Общая оценка сложности алгоритмов показана в таблице 2.

Таблица 2



|Сортировка|Сложность|
| - | - |
|Shift-Or|n \* m (где n - длина паттерна, m - длина строки)|
|Бойера-Мура|n + m (где n - длина паттерна, m - длина строки)|
